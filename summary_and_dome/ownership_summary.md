# Rust 所有权、引用和借用总结

## 核心概念

### 1. 所有权 (Ownership)
- **每个值都有一个所有者**
- **同一时间只能有一个所有者**
- **所有者离开作用域时，值被销毁**

```rust
let s1 = String::from("hello");
let s2 = s1; // 所有权转移，s1 失效
// println!("{}", s1); // 编译错误！
```

### 2. 引用 (References)
- **借用值而不获取所有权**
- **使用 & 符号创建引用**
- **引用离开作用域时不会销毁值**

```rust
let s1 = String::from("hello");
let len = calculate_length(&s1); // 借用 s1
println!("{}", s1); // s1 仍然有效
```

### 3. 借用规则 (Borrowing Rules)
1. **可以有任意数量的不可变引用**
2. **只能有一个可变引用**
3. **不可变引用和可变引用不能同时存在**
4. **引用必须总是有效的**

```rust
let mut s = String::from("hello");

// ✅ 多个不可变引用
let r1 = &s;
let r2 = &s;

// ✅ 一个可变引用
let r3 = &mut s;

// ❌ 不能同时存在
// let r4 = &s;     // 错误！
// let r5 = &mut s; // 错误！
```

### 4. 切片 (Slices)
- **对集合部分元素的引用**
- **不拥有数据的所有权**
- **字符串切片类型是 &str**

```rust
let s = String::from("hello world");
let hello = &s[0..5];  // 字符串切片
let world = &s[6..11];
```

## 为什么需要这些规则？

1. **内存安全**: 防止悬垂指针、双重释放等问题
2. **数据竞争**: 编译时防止并发访问冲突
3. **零成本抽象**: 运行时没有额外开销
4. **确定性**: 明确的内存管理，无需垃圾回收器

## 实用技巧

- 优先使用引用而不是所有权转移
- 尽可能使用不可变引用
- 使用 `.clone()` 进行深拷贝（有性能开销）
- 字符串字面量默认是 `&str` 类型
- 函数参数优先使用 `&str` 而不是 `&String`